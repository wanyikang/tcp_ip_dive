my question:
1，为什么要三次握手？
因为要互相交换ISN和MSS信息，最少得三次报文交互才能完成


2, 为什么要四次挥手？
因为tcp支持half-closing，所以至少要四次报文交互才能完成挥手动作


3，为什么要有2MSL的时间？



exercise:
18.1
I don't know


18.2
第一种情况sock程序使用一个ASCII字符的newline进行传输，第二种情况telnet使用2个ASCII字符的newline进行传输


18.3
半关闭：tcp连接是双向通信的，半关闭指通信一端发出FIN，对端回ACK后，对端不立即发送FIN，而是继续发送数据，
主动关闭端一直等待对端的FIN报文。
半打开：指通信的一端已经丢失连接了(例如电脑掉电)，对端不知道的情况。


18.4
tcp连接只有处于established状态并且主动关闭连接时才有会经历2MSL状态


18.5
从打印语句connection closed by peer可以看出此时是服务器执行了主动关闭连接的操作,
所以2MSL状态是服务器端在经历，所以连续运行两次客户端程序能以同一个端口建立连接，而服务器端也是同一个端口的原因在于
大多数BSD版的OS实现TCP协议时支持2MSL的状态时也可以建立连接，只要新的sequence
number 大于前一个替身的最后一个sequence number


18.6
BSD实现处于FIN_WAIT_2状态的一端在等待10分57秒后将状态直接变更为closed，所以12分钟后主动关闭端已经closed的了，
现在发送FIN相当于在一个已经关闭的连接上发送FIN，应该用reset报文回应


18.7
拨打电话的一端是主动打开，电话响铃的一端是被动打开，不清楚是否允许同时打开和关闭，但TCP是支持同时打开和关闭的。


18.8
服务器断开连接的情况下，我们将只看到ARP请求报文，而不是TCP的SYN报文。


18.9
solaris主机是客户端，bsdi主机是服务器，三次握手的最后一个ack连同256字节的数据一起被送到了服务器端，第3个报文
显示的就是这个情况。客户端在发完数据后没有等服务器对数据部分的ack，而是紧接着发送了FIN报文，而服务器端对数据
和FIN报文在一个ack中一同回复了，第5个报文显示的就是这种情况，最后两个是服务器的FIN报文和客户端的ack。


18.10
1，应用进程需要时间来接受EOF，然后告诉它的TCP关闭它这一端的连接
2，服务器接收到客户端的FIN后，并不一定要关闭它这一端的的连接。


18.11
第6个报文到达服务器后，报文里面的ack就是26368002，从三次握手的第二个报文可以看出服务器的序列号从26368001开始
计数，第六个报文中的ack即为26368002。而RST的序号就是到达的ack。


18.12
查询路径MTU实际上也是IP层做的的事情，IP层为TCP提供的服务。


18.13
pass


18.14
假定新建一个连接到关闭一个连接的时间忽略不计，系统除well-know端口外还有65536-1024＝64512个端口，则瞬间64512个
端口即被用完，等待2MSL＝240s后第一个连接端口才变得可用，即平均每秒可用连接64512/240=268.8，即最大268个每秒。


18.15
pass


18.16
pass


18.17
pass


18.18
不对，接收的tcp数据报通过源IP，源端口，目的IP，目的端口进行区分。例如tcp服务器可以通过目的IP地址来拒绝请求。
也可以通过限定源IP的方式提供服务，尽管大部分实现不支持。

